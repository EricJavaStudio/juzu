We will study in this chapter how to build and deploy a Juzu application.

== Introduction

Building a Juzu application is usually done in two steps:

* Compile the application to classes
* Package the application as a web application (_war_ file)

Compiling an application requires a few jars to be present on the compilation classpath:

* The Juzu core jar for the Juzu API
* The JSR-330 jar for the @Inject API
* Any Juzu extension jar such as plugins or additional template engines

After compilation, the compiled classes are packaged as a web application archive (_war_) and then deployed in a server. We
will show several ways to package your Juzu application.

== Juzu dependencies

Let's start by looking at the dependencies required by Juzu, there are several types of dependencies:

* compilation time dependencies used during the compilation of the application: for instance the Less plugin
 transforms a _less_ file into a _css_
* runtime dependencies used when the application is running
** provided by server like the _@Inject_ jar provided by an EE server but not by a Servlet Container
** embedded in the application like Groovy

=== Juzu core dependendencies

Juzu is built on top of a plugin architecture allowing to reduce the number of dependencies to the minimum for the core
of the framework.

.Juzu core dependencies
[cols="5*^",options="header"]
|===
|
|GAV
|Compilation
|Servlet Container
|Java EE Server

|Juzu
|org.juzu:juzu-core
|&#x2611;
|&#x2611;
|&#x2611;

|Groovy
|org.codehaus.groovy:groovy-all
|&#x2610;
|&#x2611;
|&#x2611;

|@Inject
|javax.inject:javax.inject
|&#x2611;
|&#x2611;
|&#x2610;
|===

=== Injection Container dependendencies

Juzu leverages an Injection Container (IOC) at runtime for wiring the various objects managed by the framework. Several
implementations can be used and you should configure the correct dependencies according to the container you are using:

* _Spring 3_
* _Google Guice 3_
* Context and Dependency Injection
** _CDI_ provided by the server
** _Weld_ the CDI implementation managed by Juzu

NOTE: _Context and Dependency Injection_ specification is an extension (JSR 299) of the _@Inject_ specification (JSR-330)

These implementation jars are never required at compilation time, unless you use specific classes in your project, such
as the +@Autowire+ annotation of Spring, or the +@Produces+ annotation of CDI.

At runtime the jars you needs depends on the implementation you use:

.IOC dependencies
[cols="3*^",options="header"]
|===
|
|Servlet Container
|Java EE Server

|Spring
|&#x2611;
|&#x2611;

|Google Guice
|&#x2611;
|&#x2611;

|Weld
|&#x2611;
|&#x2610;

|CDI
|&#x2611;
|&#x2610;
|===

NOTE: When using CDI with a Servlet Container, you need to chose an implementation of CDI and configure it
specifically for the Servlet Container, for instance you can configure
http://docs.jboss.org/weld/reference/1.0.0/en-US/html/environments.html#d0e4998[the Weld implementation for Tomcat 7].

== Packaging a Juzu application

Packaging a Juzu application is quite easy to achieve when you know which dependencies Juzu and the runtime expect
or provide. Juzu jars are deployed in the http://search.maven.org/[Maven Central repository].

When packaging your application you can follow:

[cols="4*^",options="header"]
|===
|
|Compilation
|Servlet Container
|EE Container

|+org.juzu:juzu-core+
|&#x2611;
|&#x2611;
|&#x2611;

|+org.codehaus.groovy:groovy-all+
|&#x2611;
|&#x2611;
|&#x2611;

|+javax.inject:javax.inject+
|&#x2611;
|&#x2611;
|&#x2610;

|Guice
|&#x2610;
|&#x2611;
|&#x2611;

|Spring
|&#x2610;
|&#x2611;
|&#x2611;

|CDI
|&#x2610;
|&#x2611;
|&#x2610;
|===

== Build

Every Juzu application is just a web application, any build system or IDE cab achieve it easily. We are going to
cover the cases of Maven and Gradle builds as well as a few IDEs.

=== Build with Maven

The Maven war packaging is a convenient way for building a web application with Maven. In the following examples we
will show the Maven configuration for a couple of examples, all the configurations are listed in the appendix of this guide:

* <<servlet_guice>>
* <<servlet_spring>>
* <<servlet_cdi>>
* <<ee_guice>>
* <<ee_spring>>
* <<ee_cdi>>
* <<gatein_guice>>
* <<gatein_spring>>
* <<gatein_cdi>>

NOTE: we don't need to depend on the Groovy jar as it is a compile dependency of
org.juzu:juzu-core artifact and it will be present thanks to dependencies transitivity

==== Example 1: Spring in a Servlet Container

[source,xml,indent=0]
.Maven dependencies for Spring in a servlet container
----
include::{sourcesdir}/META-INF/maven/org.juzu/juzu-booking/pom.xml[tags=spring]
----

==== Example 2: CDI

_CDI_ is supported natively by an _EE_ container and requires specific integration for a servlet container like _tomcat_

===== CDI for an EE container

Here are the dependencies for an EE container.

[source,xml,indent=0]
.Maven dependencies for CDI in an EE container
----
include::{sourcesdir}/META-INF/maven/org.juzu/juzu-booking/pom.xml[tags=ee-cdi]
----

===== CDI for a Servlet container

Using CDI with the Weld reference implementation in a Servlet Container requires  extra configuration of the web application
described in the http://docs.jboss.org/weld/reference/1.0.0/en-US/html/environments.html#d0e4998[Weld manuel], let's look
 first at the jar dependencies

[source,xml,indent=0]
.Maven dependencies for CDI in a servlet container
----
include::{sourcesdir}/META-INF/maven/org.juzu/juzu-booking/pom.xml[tags=cdi]
----

We need specific elements in _web.xml_ for integrating CDI with a servlet container:

[source,xml,indent=0]
.Servlet container configuration for CDI
----
<listener>
  <listener-class>org.jboss.weld.environment.servlet.Listener</listener-class>
</listener>
<resource-env-ref>
  <resource-env-ref-name>BeanManager</resource-env-ref-name>
  <resource-env-ref-type>javax.enterprise.inject.spi.BeanManager</resource-env-ref-type>
</resource-env-ref>
----

In addition we need also a _META-INF/context.xml_ file that contains specific Tomcat configuration:

[source,xml,indent=0]
.Maven Tomcat context.xml configuration
----
include::{sourcesdir}/META-INF/context.xml[]
----

==== Juzu archetype

The following creates a base Juzu application for Tomcat with the Guice injection container:

.Generating an application for the Tomcat server and the Guice injection container
[subs="attributes,specialcharacters"]
----
mvn archetype:generate \
   -DarchetypeGroupId=org.juzu \
   -DarchetypeArtifactId=juzu-archetype \
   -DarchetypeVersion={juzu-version} \
   -DgroupId=org.example \
   -DartifactId=myapp \
   -DpackageName=org.example.myapp \
   -Dversion=1.0.0-SNAPSHOT
----

The generated application is a quickstart ready to can be customized for developing more complex applications.

It is possible to generate the application for a different server and injection container:

.Generating an application for the Tomcat server and the Spring injection container
[subs="attributes,specialcharacters"]
----
mvn archetype:generate \
   -DarchetypeGroupId=org.juzu \
   -DarchetypeArtifactId=juzu-archetype \
   -DarchetypeVersion={juzu-version} \
   -DgroupId=org.example \
   -DartifactId=myapp \
   -DpackageName=org.example.myapp \
   -Dversion=1.0.0-SNAPSHOT \
   -DjuzuServer=servlet \
   -DjuzuInject=spring
----

Valid _juzuServer_ values are _servlet_, _ee_ or _gatein_.
Valid _juzuInject_ values are _guice_, _spring_ or _cdi_.

=== Build with Gradle

Building a Juzu application with Gradle is very easy with the _war_ Gradle plugin, here is an example of _build.gradle_ file:

.Building an application with Gradle
[subs="attributes,specialcharacters"]
----
apply plugin: 'war'
repositories {
  mavenCentral()
}
dependencies {
  compile group: 'org.juzu', name: 'juzu-core', version: '{juzu-version}'
  compile group: 'org.juzu', name: 'juzu-plugins-servlet', version: '{juzu-version}'
  compile group: 'javax.inject', name: 'javax.inject', version: '{inject-version}'
  providedCompile group: 'javax.servlet', name: 'javax.servlet-api', version: '{servlet-version}'
  runtime group: 'org.springframework', name: 'spring-web', version: '{spring-version}'
}
----

=== Using a prepackaged application

The Juzu distribution contains the Booking and Tutorial applications for GateIn and Liferay servers. They can be used
as basis to create applications.

=== Using an IDE

Juzu uses Annotation Processing Tool to perform many tasks at compilation time. APT is a standard extension of a Java compiler.
All Java IDE (Eclipse, Intellij and Netbeans) provide good support for APT, we will show in the section how to configure
and uses APT within those IDEs.

IDEs provide also Maven support, we will focus in this section on using APT without the Maven support. Indeed the APT support
may work differently when using Maven in your project, the Maven and APT support within IDEs has a dedicated section.

==== Intellij support

todo

==== Eclipse support

todo

==== Netbeans support

todo

== Run

=== Run modes

Juzu defines three modes for running an application, called _run modes_:

* Production (_prod_): error reporting is minimal
* Development (_dev_): provides verbose error reporting
* Live (_live_): allow to develop the application live with verbose error reporting

=== How to choose the right run mode

* When you are running an application use the _prod_ run mode
* When you are developing an application with a build system use the _dev_ run mode
* When you are live developing an application use the _live_ run mode

=== Configuring the run mode

Run mode is configured via servlet context parameters, by default the _prod_ mode is enabled:

* _juzu.run_mode_ : possible values _prod_, _dev_ or _live_
* _juzu.src_path_ : the source path of the source to compile for the live mode

.Configuring the dev mode in web.xml
[source,xml]
----
<context-param>
  <param-name>juzu.run_mode</param-name>
  <param-value>dev</param-value>
</context-param>
----
