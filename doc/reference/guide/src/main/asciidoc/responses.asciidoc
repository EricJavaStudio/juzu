Each request produces a response object: a subclass of the +juzu.Response+ class.

Response objects are returned by method processing phases, the class of the object determines the kind of response
sent to the client. A response object may carry additional objects such as assets (css or script).

Response object are created thanks to the static factory methods of the +juzu.Response+ class. The +Response+
class is abstract and it has several subclasses that form a possible hierarchy of response adapted to the phase
being processed.

== Content responses

A _content_ response is a markup or binary data, it can be created with the +ok+ static method:

[source,java]
----
  public static Response.Content<Stream.Char> ok(CharSequence content) { ... }
----

It can be used during a _view_ or _resource_ phase to return markup:

[source,java]
----
@View
public Response.Content index() {
  return Response.ok("Hello World");
}
----

=== Render response

A _render_ response extends a _content_ response, it specializes it for aggregated markup, i.e a response where the
 application manages only one portion of the full page such as a portal:

[source,java]
----
@View
public Response.Content index() {
  return Response.ok("Hello World").withTitle("The Hello");
}
----

=== Response mime type

The response mime type can be set on using the response properties with +PropertyType.MIME_TYPE+ property:

[source,java]
----
@View
public Response.Content index() {
  return Response.ok("Hello World").with(PropertyType.MIME_TYPE, "text/html");
}
----

This can also be achieved with the +@MimeType+ annotation:

[source,java]
----
@View
@MimeType("text/html")
public Response.Content index() {
  return Response.ok("Hello World");
}
----

or the +MimeType.HTML+ can be used as a shortcut:

[source,java]
----
@View
@MimeType.HTML
public Response.Content index() {
  return Response.ok("Hello World");
}
----

=== JSON response

Producing a JSON response can done using the _Jackson+ plugin. It can encode a native JsonTree or an object using
the Jackson mapper. The plugin can be used in your Maven build using a simple dependency:

[source,xml,subs="attributes,specialcharacters"]
----
<dependency>
  <groupId>org.juzu</groupId>
  <artifactId>juzu-plugin-jackson</artifactId>
  <version>{juzu-version}</version>
</dependency>
----

==== Encoding an object

[source,java]
----
@View
@MimeType.JSON
@Jackson
public MyObj index() {
  return new MyObj("Hello World");
}
----

The +@Jackson+ annotation is mandatory to tell the Jackson plugin it should encode the response. Indeed there could
be several plugin able to handle the _application/json_ mime type.

==== Encoding a Json tree

[source,java]
----
@View
@MimeType.JSON
public TreeNode index() {
  JsonNodeFactory factory = JsonNodeFactory.instance;
  return factory.factory.textNode("Hello World");
}
----

== View response

_View_ response is returned after the _action_ phase to configure the next _view_ phase. Usually view responses are not
created directly using static factory methods, instead they are created using controller companion static methods, this is
<<controller_action_view,explained>> in the controller chapter.

== Redirect response

_Redirect_ responses are returned during an _action_ phase to redirect the user agent to an URL, its usage is simple:

[source,java]
----
@Action
public Response.Redirect process() {
  return Response.redirect("http://www.host.com/");
}
----

== Error response

_Error_ response can be returned during any phase to signal an application error. This kind of response is different
from a content response with a 5xx status code, however it can be turned into a 5xx response to the client.

[source,java]
----
@View
public Response index() {
  try {
    ...
  } catch(IOException e) {
    return Response.error(e);
  }
}
----

An error response can also be generated by the controller method by declaring the exception in its throw clause, so the
previous example is equivalent to:

[source,java]
----

@View
public Response index() throws IOException {
  ...
}
----
